/**
 *  This library requires a ./config/default.json file in your root folder
 *  with following keys:
 *
 "kafka": {
    "brokersList": ["localhost:9092"],
    "consumerGroupId": "tasksClient",
    "clientId": "test",
    "topics": ["three"],
    "msgPerFile": 500
 }
 *
 *  otherwise the connect method rejects an error.
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under no licenses and is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */

/**
 * Author - Sanzhar Kuliev
 * Materials - Property of Askartec LLC
 */
const Kafka = require('node-rdkafka');
const config = require('config');
const fs = require('fs');
const path = require('path');
const mkdirp = require('mkdirp');

const QUEUE_DIR = './tmp/pendingQueue/';

class Producer {
    constructor(errCB) {
        this.producerConfigs = {};
        this.producer = {};
        this.errorCallback = errCB;
        this.topicOpts = {};
        this.options = {};

        this.queue = [];
        this.currQueueFile = '';
        this.messagesWrittenToFile = 0;
        this.numOfFilesPending = 0;
    }

    /**
     * Connection method must be called before any actions are taken
     * @throws {Error} in case the connection does not succeed
     */
    async connect() {
        return new Promise((resolve, reject) => {
            try {
                this.producerConfigs = config.get('kafka');

            } catch (err) {
                console.error('Error reading kafka configs: ', err);
                let error = new Error('Error reading kafka configs: ' + err);
                error.code = -1;
                reject(error)
            }

            this.options = {
                'client.id': this.producerConfigs['clientId'],
                'metadata.broker.list': this.producerConfigs['brokersList'],
                'compression.codec': 'none',
                'retry.backoff.ms': 200,
                'message.send.max.retries': 10,
                'socket.keepalive.enable': true,
                'queue.buffering.max.messages': 1000000,
                'queue.buffering.max.ms': 1000,
                'dr_cb': true
            };

            this.topicOpts = {
                'request.required.acks': -1
            };

            this.producer = new Kafka.Producer(this.options, this.topicOpts);

            // In case the client is unable to connect we throw an error
            this.producer.connect({}, (err) => {
                if (err)
                    reject(error)
            });

            //required for delivery-report event
            this.producer.setPollInterval(1000);

            this.producer
                .on('ready', () => {
                    resolve({})
                })

                .on('event.error', this.onError_)

                // In case we lost connection to Kafka a 'delivery-report' with an error is triggered
                // We don't want to lose the messages, hence we store them in a local file at
                // queueDir = './tmp/pendingQueue/' until we are back online with a Kafka cluster
                .on('delivery-report', (err, report) => {
                    if (err) {
                        this.onError_();
                        if (this.queue.length >= this.producerConfigs['queueLimit']) {
                            this.writeToFile_();
                        }
                        else {
                            this.queue.push(report);
                        }
                        // console.error(err);
                    } else {
                        this.onBackOnline_();
                    }
                });
        })
    }

    send(_topic, _msg, _key = null) {
        try {
            this.producer.produce(
                //topic
                _topic,
                //partition, default is -1
                -1,
                //message
                new Buffer(_msg),
                //key
                _key,
                //timestamp
                Date.now()
            );
        } catch (err) {
            console.error('Error sending messages to Kafka: ', err);
            this.onError_('Error sending messages to Kafka: ' + err);
        }
    }

    /**
     * In case we receive a report on unsent message from Kafka we store it in a local queue[]
     * when the number of messages reaches the limit provided in the configs
     * writeToFile_() writes it to /tmp
     *
     * @private writeToFile_
     * @return {null} if an error was encountered
     * *the error is sent up to the error callback function provided in the constructor
     */
    writeToFile_() {
        let fileQueue = this.queue;
        let qlen = fileQueue.length;

        this.currQueueFile = QUEUE_DIR + 'kafka' + this.numOfFilesPending.toString() + '.txt';

        for (let i = 0; i < qlen; i++) {
            try {
                fs.appendFileSync(this.currQueueFile, (JSON.stringify(fileQueue[i])) + '\n');
                this.messagesWrittenToFile++;

            }
            catch
                (err) {
                console.error('Error writing to file:', err);
                this.onError_('Error writing to file:' + err);
                return null;
            }
        }

        this.queue = [];
        this.numOfFilesPending++;
    }

    /**
     * sendFromFiles_() is invoked once we are back online with the Kafka cluster
     * It dumps temp/pendingQueue into Kafka
     *
     * @private sendFromFiles_
     * @throws {Error} if the tmp/pendingQueue/ directory has failed at being created/opened
     * @return {null} if an error has been encounter during execution
     * @callback is invoked if an error has been encounter during execution
     */
    sendFromFiles_() {
        /**
         * _files is a preliminary var for files to be dumped
         * @type {{}}
         */
        let _files = {};

        // An attempt to open/create tmp directory for local messages storage it throws error in case of failure
        mkdirp.sync(QUEUE_DIR, function (err) {
            if (err) {
                console.error('Unable to open or create ' + QUEUE_DIR, err);
                throw err;
            }
        });

        //Loading the /tmp/pendingQueue/ into the buffer
        try {
            _files = fs.readdirSync(QUEUE_DIR);
        } catch (err) {
            console.error('Error reading directory ' + QUEUE_DIR + ' :', err);
            this.onError_('Error reading directory ' + QUEUE_DIR + ' :' + err);
            return null;
        }
        if (!_files) return null;

        // Here we dump the tmp/pendingQueue directory messages into Kafka
        for (let i in _files) {
            let isReadError = false;
            let currFile = _files[i];

            if (path.extname(currFile) !== '.txt') continue;

            let currMsg = [];
            let currFilePath = path.join(QUEUE_DIR, currFile);

            try {
                currMsg = fs.readFileSync(currFilePath, 'utf-8').split('\n');
            } catch (err) {
                console.error('Can\'t open ' + currFile + ' file: ', err);
                this.onError_('Can\'t open ' + currFile + ' file: ' + err);
                isReadError = true;
            }

            //Everything is OK parsing messages and sending them to Kafka
            if (!isReadError) {
                for (let i in currMsg) {
                    if (currMsg[i] === '') continue;

                    let line = {};
                    try {
                        line = JSON.parse(currMsg[i]);
                    } catch (err) {
                        console.error('Error reading log record: ', err);
                        this.onError_('Error reading log record: ' + err);
                        continue;
                    }

                    exports.send(line.topic, line.value.data.toString(), line.key)
                }
            }
        }
    }

    shutdown() {
        if (this.producer != null) {
            this.producer.disconnect();
        }
    }

    onBackOnline_() {
        this.sendFromFiles_();
    }

    onError_(err) {
        this.errorCallback(err);
    }
}

module.exports = Producer;

